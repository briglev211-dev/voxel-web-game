<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini-Minecraft (JS demo)</title>
<style>
  html,body { height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial; background:#111; color:#ddd;}
  #game { display:flex; gap:12px; padding:12px; box-sizing:border-box; height:100vh; }
  canvas { background:#7ec0ee; border-radius:8px; box-shadow:0 6px 20px rgba(0,0,0,0.6); }
  #ui { width:300px; display:flex; flex-direction:column; gap:10px; }
  .panel { background:rgba(0,0,0,0.45); padding:10px; border-radius:8px; }
  #inventory { display:flex; flex-wrap:wrap; gap:6px; }
  .slot { width:56px; height:56px; background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.03); border-radius:6px; display:flex; align-items:center; justify-content:center; flex-direction:column; font-size:12px; color:#fff; }
  .slot img { width:28px; height:28px; pointer-events:none; }
  .hud { color:#fff; font-size:13px; }
  button { background:#1d1f21; color:#ddd; border:1px solid rgba(255,255,255,0.05); padding:6px 8px; border-radius:6px; cursor:pointer;}
  small { color:#aaa; display:block; margin-top:6px; }
</style>
</head>
<body>
<div id="game">
  <canvas id="c" width="960" height="640"></canvas>
  <div id="ui">
    <div class="panel">
      <div class="hud"><strong>Mini-Minecraft (demo)</strong></div>
      <small>WASD to move • Left-click to mine / attack • Move near an item to auto-pickup</small>
    </div>

    <div class="panel">
      <div class="hud"><strong>Inventory</strong></div>
      <div id="inventory"></div>
    </div>

    <div class="panel">
      <div class="hud"><strong>Debug</strong></div>
      <div id="debug"></div>
    </div>

    <div class="panel">
      <div style="display:flex; gap:6px;">
        <button id="resetBtn">Reset World</button>
        <button id="centerBtn">Center Player</button>
      </div>
    </div>
  </div>
</div>

<script>
/*
Mini-Minecraft demo
- chunked generation (16x16 tiles per chunk)
- simple random-based tree spawn and passive mobs
- mining blocks -> items to inventory
- mobs drop food when killed by player
*/

(() => {
  // CONFIG
  const TILE = 32;                      // px per tile
  const CHUNK_SIZE = 16;                // tiles per chunk (square)
  const VISIBLE_RANGE = 3;              // chunks radius to keep generated
  const CANVAS_W = 960, CANVAS_H = 640;

  // Block types
  const BLOCKS = {
    air: { id:'air', solid:false },
    grass: { id:'grass', color:'#3CAA2A', breakTime: 1, drop:'dirt', solid:true },
    dirt: { id:'dirt', color:'#976B3D', breakTime: 1, drop:'dirt', solid:true },
    stone: { id:'stone', color:'#7f8a93', breakTime: 2, drop:'stone', solid:true },
    trunk: { id:'trunk', color:'#6b3f2f', breakTime: 1, drop:'wood', solid:true },
    leaf: { id:'leaf', color:'#4fb654', breakTime: 0.2, drop:'leaf', solid:false }
  };

  // Items (simple)
  const ITEM_TEMPLATES = {
    dirt: { id:'dirt', display:'Dirt' },
    stone: { id:'stone', display:'Stone' },
    wood: { id:'wood', display:'Wood' },
    meat: { id:'meat', display:'Meat (food)' },
    leaf: { id:'leaf', display:'Leaf' }
  };

  // helper seeded RNG per chunk coords for deterministic chunks
  function seededRand(x, y, seed=1337) {
    // returns function() -> 0..1
    let n = (x*374761393 + y*668265263) ^ seed;
    return function() {
      n = (n ^ (n << 13)) >>> 0;
      n = (n * 1274126177) >>> 0;
      return ((n) % 10000) / 10000;
    };
  }

  // Helper clamp
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

  // World, chunks and tile map
  class Chunk {
    constructor(cx, cy) {
      this.cx = cx; this.cy = cy;
      this.tiles = new Array(CHUNK_SIZE * CHUNK_SIZE).fill('air');
      this.blockHP = {}; // key: idx => hp (for partially damaged blocks)
      this.items = [];   // dropped items in chunk: {xTile, yTile, itemId, stack}
      this.mobs = [];    // mobs in chunk
      this.generate();
    }
    idx(tx, ty){ return tx + ty*CHUNK_SIZE; }
    get(tx, ty){
      if(tx < 0 || ty < 0 || tx >= CHUNK_SIZE || ty >= CHUNK_SIZE) return 'air';
      return this.tiles[this.idx(tx,ty)];
    }
    set(tx,ty, blockId) {
      if(tx < 0 || ty < 0 || tx >= CHUNK_SIZE || ty >= CHUNK_SIZE) return;
      this.tiles[this.idx(tx,ty)] = blockId;
    }
    generate(){
      const rand = seededRand(this.cx, this.cy, 12345);
      // base ground height around 8-11 inside chunk
      const baseH = 6 + Math.floor(rand()*6);
      for(let y=0;y<CHUNK_SIZE;y++){
        for(let x=0;x<CHUNK_SIZE;x++){
          const worldY = this.cy*CHUNK_SIZE + y;
          if(worldY > baseH + Math.floor(rand()*2)) {
            this.set(x,y,'dirt');
          } else if(worldY === baseH) {
            this.set(x,y,'grass');
          } else if(worldY < baseH - 3) {
            this.set(x,y,'stone');
          } else {
            this.set(x,y,'air');
          }
        }
      }

      // randomly spawn a few trees
      if(rand() < 0.75) {
        const tries = 3;
        for(let t=0;t<tries;t++){
          if(rand() < 0.25) {
            const tx = Math.floor(rand()*CHUNK_SIZE);
            // find surface at this tx
            let surfaceY = null;
            for(let y=0;y<CHUNK_SIZE;y++){
              if(this.get(tx,y) === 'grass'){ surfaceY = y; break; }
            }
            if(surfaceY!==null) {
              // place small tree
              const trunkHeight = 3 + Math.floor(rand()*2);
              for(let h=1;h<=trunkHeight;h++) this.set(tx,surfaceY-h,'trunk');
              // leaves: small blob
              for(let ly=-2; ly<=0; ly++){
                for(let lx=-2; lx<=2; lx++){
                  const ax = tx+lx;
                  const ay = surfaceY - trunkHeight + ly;
                  if(ax>=0 && ax<CHUNK_SIZE && ay>=0 && ay<CHUNK_SIZE){
                    if(rand() < 0.85) this.set(ax, ay, 'leaf');
                  }
                }
              }
            }
          }
        }
      }

      // spawn some passive mobs
      // chance of having 0..2 mobs
      const mobCount = Math.floor(rand()*2.2);
      for(let i=0;i<mobCount;i++){
        const rx = Math.floor(rand()*CHUNK_SIZE);
        // find surface
        let sy = null;
        for(let y=0;y<CHUNK_SIZE;y++){
          if(this.get(rx,y) === 'grass'){ sy = y-1; break; } // mob stands above grass (y-1 tile is air)
        }
        if(sy!==null && sy>=0){
          // place mob slightly inside tile coordinates (world coords)
          const mob = new Mob(this.cx*CHUNK_SIZE + rx + 0.5, this.cy*CHUNK_SIZE + sy + 0.9);
          this.mobs.push(mob);
        }
      }
    }
  }

  class World {
    constructor() {
      this.chunks = new Map(); // key `${cx},${cy}` -> Chunk
    }
    key(cx,cy){ return `${cx},${cy}`; }
    getChunk(cx,cy){
      const k = this.key(cx,cy);
      if(this.chunks.has(k)) return this.chunks.get(k);
      const ch = new Chunk(cx,cy);
      this.chunks.set(k, ch);
      return ch;
    }
    ensureAround(wx, wy){
      // ensure chunks in range around tile coordinate wx,wy exist
      const cx = Math.floor(wx / CHUNK_SIZE);
      const cy = Math.floor(wy / CHUNK_SIZE);
      for(let oy=-VISIBLE_RANGE; oy<=VISIBLE_RANGE; oy++){
        for(let ox=-VISIBLE_RANGE; ox<=VISIBLE_RANGE; ox++){
          this.getChunk(cx+ox, cy+oy);
        }
      }
    }
    worldToChunkTile(wx, wy){
      const cx = Math.floor(wx / CHUNK_SIZE);
      const cy = Math.floor(wy / CHUNK_SIZE);
      const tx = ((wx % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
      const ty = ((wy % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
      return {cx,cy,tx,ty};
    }
    getBlockAt(wx, wy){
      const {cx,cy,tx,ty} = this.worldToChunkTile(wx,wy);
      return this.getChunk(cx,cy).get(tx,ty);
    }
    setBlockAt(wx, wy, id){
      const {cx,cy,tx,ty} = this.worldToChunkTile(wx,wy);
      this.getChunk(cx,cy).set(tx,ty,id);
    }
    addDroppedItemAt(wx, wy, itemId, stack=1){
      const {cx,cy,tx,ty} = this.worldToChunkTile(wx,wy);
      const ch = this.getChunk(cx,cy);
      ch.items.push({xTile:cx*CHUNK_SIZE+tx, yTile:cy*CHUNK_SIZE+ty, itemId, stack, age:0});
    }
    update(dt, player){
      // update mobs and items in all loaded chunks
      for(const ch of this.chunks.values()){
        // items: age them
        ch.items.forEach(it => it.age += dt);
        // remove items older than some time? keep for now

        // update mobs
        for(const mob of ch.mobs){
          mob.update(dt, this, player);
        }
      }
    }

    forEachVisibleChunks(cx, cy, radius, fn){
      for(let oy=-radius; oy<=radius; oy++) for(let ox=-radius; ox<=radius; ox++){
        const ch = this.getChunk(cx+ox, cy+oy);
        fn(ch, cx+ox, cy+oy);
      }
    }
  }

  // Player
  class Player {
    constructor(x=0,y=0) {
      this.x = x; this.y = y; // world tile coords (float)
      this.speed = 6; // tiles per second
      this.health = 10;
      this.attackRange = 1.6; // tiles
      this.attackDamage = 5;
      this.inventory = {}; // itemId -> count
    }
    addItem(id, n=1){
      if(!this.inventory[id]) this.inventory[id] = 0;
      this.inventory[id] += n;
    }
    update(dt, input){
      let dx=0, dy=0;
      if(input.keys['w']) dy -= 1;
      if(input.keys['s']) dy += 1;
      if(input.keys['a']) dx -= 1;
      if(input.keys['d']) dx += 1;
      if(dx!==0 || dy!==0){
        const len = Math.hypot(dx,dy);
        dx/=len; dy/=len;
        this.x += dx * this.speed * dt;
        this.y += dy * this.speed * dt;
      }
    }
  }

  // Simple mob
  class Mob {
    constructor(x,y){
      this.x = x; this.y = y; // world tile float coords
      this.vx = 0; this.vy = 0;
      this.speed = 1.2;
      this.hp = 6;
      this.maxHp = 6;
      this.wanderTimer = 0;
    }
    update(dt, world, player){
      // wander randomly
      this.wanderTimer -= dt;
      if(this.wanderTimer <= 0){
        this.wanderTimer = 1 + Math.random()*3;
        const ang = Math.random()*Math.PI*2;
        this.vx = Math.cos(ang) * this.speed;
        this.vy = Math.sin(ang) * this.speed * 0.5; // less vertical movement
      }
      // simple movement allowed if next tile not solid (very permissive)
      const nx = this.x + this.vx * dt;
      const ny = this.y + this.vy * dt;
      const blockBelow = world.getBlockAt(Math.floor(nx), Math.floor(ny+0.9));
      if(blockBelow === 'air') {
        // fall a bit
        this.y += 0.5 * dt;
      } else {
        this.x = nx; this.y = ny;
      }
      // if player very near (but we keep mobs passive), we do nothing
    }
    takeDamage(dmg){
      this.hp -= dmg;
      return this.hp <= 0;
    }
  }

  // Input
  const Input = {
    keys: {},
    mouseDown: false,
    mouseX:0, mouseY:0,
    setup(canvas) {
      window.addEventListener('keydown', (e)=>{ this.keys[e.key.toLowerCase()] = true; });
      window.addEventListener('keyup',   (e)=>{ this.keys[e.key.toLowerCase()] = false; });
      canvas.addEventListener('mousedown', (e)=>{
        this.mouseDown = true;
        this.mouseX = e.offsetX;
        this.mouseY = e.offsetY;
      });
      canvas.addEventListener('mouseup', (e)=>{ this.mouseDown = false; this.mouseX = e.offsetX; this.mouseY = e.offsetY; });
      canvas.addEventListener('mousemove', (e)=>{ this.mouseX = e.offsetX; this.mouseY = e.offsetY; });
      // context menu off
      canvas.addEventListener('contextmenu', e=>e.preventDefault());
    }
  };

  // Renderer / Game
  class Game {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.world = new World();
      this.player = new Player(0.5, 0.5);
      this.input = Object.assign({}, Input);
      Input.setup(canvas);

      this.camera = {x:0, y:0, zoom:1};
      this.last = performance.now();
      this.accumulator = 0;

      // mining state
      this.hitProgress = 0; // track progress towards breaking block
      this.targetBlock = null;

      // bind UI
      document.getElementById('resetBtn').onclick = ()=> this.reset();
      document.getElementById('centerBtn').onclick = ()=> this.center();

      // start with generating area around player
      this.world.ensureAround(Math.floor(this.player.x), Math.floor(this.player.y));

      requestAnimationFrame((t)=>this.frame(t));
    }

    reset(){ this.world = new World(); this.player = new Player(0.5,0.5); this.world.ensureAround(0,0); }
    center(){ this.player.x = 0.5; this.player.y = 0.5; }

    frame(now){
      const dt = Math.min((now - this.last)/1000, 0.05);
      this.last = now;
      this.update(dt);
      this.draw();
      requestAnimationFrame((t)=>this.frame(t));
    }

    worldToScreen(wx, wy){
      const px = (wx - this.camera.x) * TILE * this.camera.zoom + this.canvas.width/2;
      const py = (wy - this.camera.y) * TILE * this.camera.zoom + this.canvas.height/2;
      return {x:px, y:py};
    }
    screenToWorld(sx, sy){
      const wx = (sx - this.canvas.width/2) / (TILE*this.camera.zoom) + this.camera.x;
      const wy = (sy - this.canvas.height/2) / (TILE*this.camera.zoom) + this.camera.y;
      return {x:wx, y:wy};
    }

    update(dt){
      // ensure chunks around player loaded
      this.world.ensureAround(Math.floor(this.player.x), Math.floor(this.player.y));

      // update player
      this.player.update(dt, Input);

      // update world (mobs etc.)
      this.world.update(dt, this.player);

      // camera follow
      this.camera.x += (this.player.x - this.camera.x) * 8 * dt;
      this.camera.y += (this.player.y - this.camera.y) * 8 * dt;

      // handle left click / mining / attacking
      if(Input.mouseDown) {
        const wpos = this.screenToWorld(Input.mouseX, Input.mouseY);
        const tx = Math.floor(wpos.x);
        const ty = Math.floor(wpos.y);
        const dist = Math.hypot((this.player.x - (tx+0.5)), (this.player.y - (ty+0.5)));
        // if there's a mob in range near cursor and in attack range, damage mob
        const candidate = this.findMobNearScreen(Input.mouseX, Input.mouseY);
        if(candidate && Math.hypot(candidate.x - this.player.x, candidate.y - this.player.y) <= this.player.attackRange) {
          // attack mob once per click (simple)
          if(!this._clickedThisDown){
            this._clickedThisDown = true;
            const died = candidate.takeDamage(this.player.attackDamage);
            if(died){
              // drop food at mob location
              this.world.addDroppedItemAt(Math.floor(candidate.x), Math.floor(candidate.y), 'meat', 1);
              // remove mob from its chunk
              const {cx,cy,tx,ty} = this.world.worldToChunkTile(Math.floor(candidate.x), Math.floor(candidate.y));
              const ch = this.world.getChunk(cx,cy);
              const idx = ch.mobs.indexOf(candidate);
              if(idx>=0) ch.mobs.splice(idx,1);
            }
          }
        } else {
          // mining logic: if not air, increase hit progress
          const blockId = this.world.getBlockAt(tx,ty);
          if(blockId && blockId !== 'air') {
            const block = BLOCKS[blockId];
            // only allow mining if within 4 tiles range
            const playerDist = Math.hypot(this.player.x - (tx+0.5), this.player.y - (ty+0.5));
            if(playerDist <= 4) {
              // accumulate progress based on breakTime
              const speed = 1.8; // player's mining speed multiplier
              const increment = dt * speed / (block.breakTime || 0.5);
              const key = `${tx},${ty}`;
              if(this.targetBlock !== key) {
                this.targetBlock = key;
                this.hitProgress = 0;
              }
              this.hitProgress += increment;
              if(this.hitProgress >= 1) {
                // break block
                this.world.setBlockAt(tx,ty,'air');
                // add drop to inventory (try to stack)
                const drop = block.drop || 'dirt';
                this.player.addItem(drop, 1);
                // spawn small pickable item at tile
                this.world.addDroppedItemAt(tx,ty, drop, 1);
                this.hitProgress = 0;
                this.targetBlock = null;
              }
            }
          } else {
            // clicking empty air resets mining
            this.hitProgress = 0;
            this.targetBlock = null;
          }
        }
      } else {
        this._clickedThisDown = false;
        this.hitProgress = 0;
        this.targetBlock = null;
      }

      // pickup items near player
      this.checkPickup();

      // update UI debug/inventory
      this.updateUI();
    }

    findMobNearScreen(sx, sy){
      const wpos = this.screenToWorld(sx, sy);
      const wx = Math.floor(wpos.x), wy = Math.floor(wpos.y);
      const {cx,cy,tx,ty} = this.world.worldToChunkTile(wx,wy);
      const radius = 1;
      for(let oy=-1; oy<=1; oy++) for(let ox=-1; ox<=1; ox++){
        const ch = this.world.getChunk(cx+ox, cy+oy);
        for(const mob of ch.mobs){
          // check distance from cursor
          const d = Math.hypot(mob.x - wpos.x, mob.y - wpos.y);
          if(d < 0.9) return mob;
        }
      }
      return null;
    }

    checkPickup(){
      // find items within 0.9 tiles of player and add to inventory
      for(const ch of this.world.chunks.values()){
        for(let i = ch.items.length-1; i>=0; i--){
          const it = ch.items[i];
          const dx = (it.xTile+0.5) - this.player.x;
          const dy = (it.yTile+0.5) - this.player.y;
          if(Math.hypot(dx, dy) < 0.9) {
            this.player.addItem(it.itemId, it.stack);
            ch.items.splice(i,1);
          }
        }
      }
    }

    updateUI(){
      // inventory
      const invDiv = document.getElementById('inventory');
      invDiv.innerHTML = '';
      const inv = this.player.inventory;
      const keys = Object.keys(ITEM_TEMPLATES);
      // show any items that player has
      for(const id of Object.keys(inv)){
        const count = inv[id];
        const tpl = ITEM_TEMPLATES[id] || {display:id};
        const slot = document.createElement('div');
        slot.className='slot';
        slot.innerHTML = `<div style="font-size:12px">${tpl.display}</div><div style="font-weight:700">${count}</div>`;
        invDiv.appendChild(slot);
      }
      if(Object.keys(inv).length===0){
        invDiv.innerHTML = '<div style="color:#aaa">(empty)</div>';
      }

      // debug
      const dbg = document.getElementById('debug');
      const loaded = this.world.chunks.size;
      dbg.innerHTML = `Player: ${this.player.x.toFixed(2)}, ${this.player.y.toFixed(2)}<br>Chunks loaded: ${loaded}<br>Mobs: ${[...this.world.chunks.values()].reduce((s,c)=>s+c.mobs.length,0)}<br>Items: ${[...this.world.chunks.values()].reduce((s,c)=>s+c.items.length,0)}`;
    }

    draw(){
      const ctx = this.ctx;
      ctx.clearRect(0,0,this.canvas.width, this.canvas.height);

      // draw tiles from visible chunks
      const camTileX = this.camera.x, camTileY = this.camera.y;
      const cx = Math.floor(camTileX / CHUNK_SIZE), cy = Math.floor(camTileY / CHUNK_SIZE);

      const radius = VISIBLE_RANGE + 1;
      for(let oy=-radius; oy<=radius; oy++){
        for(let ox=-radius; ox<=radius; ox++){
          const chx = cx + ox, chy = cy + oy;
          const ch = this.world.getChunk(chx, chy);
          if(!ch) continue;
          for(let ty=0; ty<CHUNK_SIZE; ty++){
            for(let tx=0; tx<CHUNK_SIZE; tx++){
              const blockId = ch.get(tx,ty);
              const worldX = chx*CHUNK_SIZE + tx;
              const worldY = chy*CHUNK_SIZE + ty;
              const scr = this.worldToScreen(worldX, worldY);
              if(blockId && blockId !== 'air'){
                const b = BLOCKS[blockId];
                ctx.fillStyle = b.color || '#999';
                ctx.fillRect(scr.x, scr.y, TILE*this.camera.zoom, TILE*this.camera.zoom);
                // little outline
                ctx.strokeStyle = 'rgba(0,0,0,0.12)';
                ctx.strokeRect(scr.x, scr.y, TILE*this.camera.zoom, TILE*this.camera.zoom);
              } else {
                // air - maybe draw a faint grid for ground
                // skip
              }
            }
          }
        }
      }

      // draw dropped items
      for(const ch of this.world.chunks.values()){
        for(const it of ch.items){
          const scr = this.worldToScreen(it.xTile + 0.2, it.yTile + 0.2);
          ctx.fillStyle = '#ffd59a';
          ctx.fillRect(scr.x, scr.y, TILE*0.6*this.camera.zoom, TILE*0.6*this.camera.zoom);
          ctx.fillStyle = '#000';
          ctx.font = `${12}px sans-serif`;
          ctx.fillText(ITEM_TEMPLATES[it.itemId]?.display || it.itemId, scr.x+2, scr.y+10);
        }
      }

      // draw mobs
      ctx.save();
      ctx.translate(0,0);
      for(const ch of this.world.chunks.values()){
        for(const mob of ch.mobs){
          const scr = this.worldToScreen(mob.x, mob.y - 0.2);
          ctx.fillStyle = '#ffd1d1';
          ctx.beginPath();
          ctx.ellipse(scr.x, scr.y, TILE*0.28*this.camera.zoom, TILE*0.4*this.camera.zoom, 0, 0, Math.PI*2);
          ctx.fill();
          // hp bar
          const barW = TILE*0.6*this.camera.zoom;
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(scr.x - barW/2, scr.y - TILE*0.55*this.camera.zoom, barW, 4);
          ctx.fillStyle = '#ff6b6b';
          ctx.fillRect(scr.x - barW/2, scr.y - TILE*0.55*this.camera.zoom, barW * (mob.hp/mob.maxHp), 4);
        }
      }
      ctx.restore();

      // draw player
      const ps = this.worldToScreen(this.player.x, this.player.y - 0.2);
      ctx.fillStyle = '#2a2a2a';
      ctx.beginPath();
      ctx.ellipse(ps.x, ps.y, TILE*0.32*this.camera.zoom, TILE*0.46*this.camera.zoom, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.fillRect(ps.x-4, ps.y-8, 8, 3);

      // draw crosshair / cursor
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fillRect(this.canvas.width/2 - 1, this.canvas.height/2 - 1, 2, 2);

      // draw mining progress if targeting a block
      if(this.targetBlock){
        // parse key
        const [tx, ty] = this.targetBlock.split(',').map(Number);
        const scr = this.worldToScreen(tx+0.5, ty+0.5);
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.strokeRect(scr.x - TILE*0.4*this.camera.zoom, scr.y - TILE*0.4*this.camera.zoom, TILE*0.8*this.camera.zoom, TILE*0.8*this.camera.zoom);
        // progress bar
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillRect(scr.x - TILE*0.4*this.camera.zoom, scr.y + TILE*0.5*this.camera.zoom, TILE*0.8*this.camera.zoom * this.hitProgress, 4);
      }
    }
  }

  // Start game
  const canvas = document.getElementById('c');
  canvas.width = CANVAS_W; canvas.height = CANVAS_H;
  const game = new Game(canvas);

  // Center camera on player at start
  game.center();
})();
</script>
</body>
</html>

